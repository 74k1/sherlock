use gio::glib;
use gtk4::{prelude::*, CssProvider, Widget, Label, ListBox};
use std::collections::HashMap;
use std::fs::{self, read_to_string, File};
use std::env;
use std::io::{BufReader, Read};
use std::path::Path;
use regex::Regex;
use serde::Deserialize;
use gtk4::gdk::Display;
use rayon::prelude::*;

use crate::CONFIG;

pub mod config_loader;

#[derive(Deserialize, Clone, Debug)]
pub struct AppData{
    pub icon: String,
    pub exec: String,
}

pub fn load_resources(){
    let res_bytes = include_bytes!("../../resources.gresources");
    let resource = gio::Resource::from_data(&glib::Bytes::from_static(res_bytes))
        .expect("Failed to load resources in helpers.");
    gio::resources_register(&resource);
}

pub fn load_css() {
    let provider = CssProvider::new();
    provider.load_from_resource("/com/skxxtz/sherlock/main.css");
    gtk4::style_context_add_provider_for_display(
        &Display::default().expect("Cound not connect to a display."),
        &provider,
        gtk4::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}

fn read_file(file_path: &str)->std::io::Result<String>{
    let file = File::open(file_path)?;
    let mut reader = BufReader::new(file);
    let mut content = String::new();
    reader.read_to_string(&mut content)?;
    Ok(content)
}

pub fn get_applications() -> HashMap<String, AppData> {
    let home_dir = env::var("HOME").unwrap_or_else(|_| String::from("/home/user"));
    let sherlock_ignore_path = format!("{}/.config/sherlock/sherlockignore", home_dir);

    //Check if user has created sherlockignore file
    let system_apps = "/usr/share/applications/";
    let mut apps: HashMap<String, AppData> = HashMap::new();
    let mut ignore_apps: Vec<String> = Default::default();

    let name_re = Regex::new(r"(?i)Name\s*=\s*(.*)\n").unwrap();
    let icon_re = Regex::new(r"(?i)Icon\s*=\s*(.*)\n").unwrap();
    let exec_re = Regex::new(r"(?i)Exec\s*=\s*(.*)\n").unwrap();
    let display_re = Regex::new(r"(?i)NoDisplay\s*=\s*(.*)\n").unwrap();
    let terminal_re = Regex::new(r"(?i)Terminal\s*=\s*(.*)\n").unwrap();

    if Path::new(&sherlock_ignore_path).exists(){
        ignore_apps = read_to_string(sherlock_ignore_path).unwrap().lines().map(String::from).collect();
    }
    
    let files:Vec<_> = fs::read_dir(system_apps)
        .expect("Unable to read/access /usr/share/applications directory")
        .filter_map(|entry| entry.ok())
        .filter(|entry| entry.path().extension().map(|ext| ext == "desktop").unwrap_or(false))
        .collect();
    {}
    files.into_par_iter()
        .map(|entry| {
            let path = entry.path().to_str().unwrap();
            match read_file(path){
                Ok(content) => content,
                Err(e) => format!("Error reading file {} : {}", path, e)
            }
        });
    





    if let Ok(entries) = fs::read_dir(system_apps) {
        for entry in entries.filter_map(Result::ok) {
            if let Some(extension) = entry.path().extension() {
                if extension == "desktop" {
                    let content = fs::read_to_string(entry.path()).expect("Error reading desktop file");

                    // Check if the "NoDisplay" field is set to "true", skip if so
                    if let Some(caps) = display_re.captures(&content) {
                        if &caps[1] == "true" {
                            continue;
                        }
                    }

                    let name = name_re.captures(&content)
                        .and_then(|caps| caps.get(1).map(|m| m.as_str().to_string()))
                        .unwrap_or_default();

                    if ignore_apps.contains(&name){
                        continue;
                    }

                    let icon = icon_re.captures(&content)
                        .and_then(|caps| caps.get(1).map(|m| m.as_str().to_string()))
                        .unwrap_or_default();  // Use default if not found

                    let terminal_bool = terminal_re.captures(&content)
                        .and_then(|caps| caps.get(1).map(|m| m.as_str().to_string()))
                        .unwrap_or_default();  // Use default if not found

                    let exec_path = exec_re.captures(&content)
                        .and_then(|caps| caps.get(1).map(|m| m.as_str().to_string()))
                        .unwrap_or_default();  // Use default if not found
                    
                    
                    let exec: String = if terminal_bool == "true"{
                        if let Some(terminal) = &CONFIG.defaults.terminal {
                            format!("{} {}", terminal, exec_path)
                        } else {
                            eprint!("E5000 No terminal found!");
                            exec_path.to_string()
                        }
                    } else {
                        exec_path.to_string()
                    };

                    if !name.is_empty() {
                        apps.insert(name, AppData { icon, exec });
                    }
                }
            }
        }
    }

    apps
}


pub fn select_first_row(results: &ListBox){
    if let Some(first_row) = results.first_child(){
        if let Some(row) = first_row.downcast_ref::<gtk4::ListBoxRow>() {
            results.select_row(Some(row));
        } 
    }
}

pub fn read_from_label(label_obj:&Widget)->Option<(String, String)>{
    if let Some(label) = label_obj.downcast_ref::<Label>(){
        let text = label.text();
        let parts: Vec<&str> = text.split(" | ").collect();

        if parts.len() == 2 {
            return Some((parts[0].to_string(), parts[1].to_string()))
        }
    }
    return None
}
